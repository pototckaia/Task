разностные списки

Простой append
append([], L, L).
append([X|T], L, [X|R]) :- append(T, L, R).
Пример:
append([1, 2], [3, 4], A).
append([1|[2]], [3, 2], [1|V_1]):- append([2], [3, 4], V_1).
append([2|[]], [3, 4], [2|V_2]):- append([], [3, 4], V_2).
append([], [3, 4], [3, 4]).
A = [1, 2, 3, 4]


Разностный список - 
объединения списка и относящуюся к нему переменную в одну структуру. Название "разностный список" объясняется тем, что структура A-B представляет список, получающийся при "вычитании" списка B из списка A.
[1,2,3|A] - A.
[1,2,3,4,5]-[4,5].
[1,2,3,acr]-[acr]. 

К разностному списку можно очень быстро присоединить другой список, присваивая его переменной, завершающей неполный список. 
?- X = [1, 2, 3|A], A=[4, 5, 6].
X = [1, 2, 3, 4, 5, 6]

Мы можем оформить эту идею, определив отношение
append_incomplete(A, B, B, C, A, C).
A first list
B the variable at the end of the first list

?- append_incomplete([1, 2, 3|A], A, [4, 5, 6|B], B, C, []).
A = [4, 5, 6]
B = []
C = [1, 2, 3, 4, 5, 6] 
Yes

По конвекции разностный список записывается как пара
A-B. При такой интерпретации определение append_d совершенно очевидно: 

append_d(A1-B1,A2-B2,A3-B3):-B1=A2,A3=A1,B3=B2.
сокращая приходим к
append_d(A-B, С-В, A-C)
A-B + B-C = A-C.

Пустой список
[|A] or A-A

Разностные списки полезны главным образом в тех случаях, когда создается большое количество коротких списков, которые затем объединяются в один. 

reverse([], []).
reverse([H|T],L) :- reverse(T,S), append(S,[H],L).

Попробуем заменить результат процедуры разностным списком. 

reverse_d([], X-X).
reverse_d([H|T],L-L1) 
	:- reverse_d(T,S-S1), append_d(S-S1,[H|X]-X,L-L1).

Используя определение append_d
reverse_d([H|T],L-L1) :- reverse_d(T,S-S1), S1=[H|X],L=S,L1=X.

reverse_d([H|T],L-X) :- reverse_d(T,L-[H|X]).

Собирая все вместе, получаем

reverse(L,R):-  reverse_d(L,R-[]).

reverse_d([],X-X).
reverse_d([H|T],L-X) :- reverse_d(T,L-[H|X]).

Еще один типичный пример - создание списка узлов двоичного дерева. Прямая реализация

nodes(empty,[]).
nodes(bt(X,Lt,Rt), [X|Xs]) :- 
    nodes(Lt,Ls), 
    nodes(Rt,Rs), 
    append(Ls,Rs,Xs).

неэффективна из-за большого количества операций соединения. Используя разностные списки, можно избавится от них и значительно повысить скорость.

nodes(T,L):-nodes_d(T,L-[]).

nodes_d(empty,L-L).
nodes_d(bt(X,Lt,Rt),[X|L]-Z) :- 
    nodes_d(Lt,L-Y), 
    nodes_d(Rt,Y-Z).


Неполный список используются для организации небольших словарей. Доступ к словарю осуществляется процедурой lookup, которая возвращает значение соответствующее ключу или добавляет пару ключ-значение в словарь. Простейшее определение этой процедуры

lookup(Key, Dict, Val):- member(Key - Val, Dict).

?- lookup(a, Dict, 1), lookup(b, Dict, 2),lookup(a, Dict, A).
Dict = [a-1, b-2|_G268]
A = 1 
Yes



